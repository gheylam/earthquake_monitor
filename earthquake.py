'''
function earthquake_exercise_setup()
    # explosion detector (using spiral coordinate system)
    # define the coordinate system:
    S=2000 # number of points on the spiral
    rate=25 # angular rate of spiral
    sd=0.2 # standard deviation of the sensor Gaussian noise

    x=zeros(S); y=zeros(S)
    for s=1:S
        theta=rate*2*pi*s/S;  r=s/S
        x[s]=r*cos(theta); y[s]=r*sin(theta)
    end

    # define the locations of the detection stations on the surface
    # Also define what value on each sensor would be generated by an explostion at internal location s
    num_pts=30 # number of stations
    x_sensor=zeros(num_pts); y_sensor=zeros(num_pts)
    v=zeros(S,num_pts)
    for sensor=1:num_pts
        theta_sensor=2*pi*sensor/num_pts
        x_sensor[sensor]=cos(theta_sensor); y_sensor[sensor]=sin(theta_sensor)
        for s=1:S
            v[s,sensor]=value(x[s],y[s],x_sensor[sensor],y_sensor[sensor]) # explosion value for some value function
        end
    end
end
'''

import numpy as np
import matplotlib.pyplot as plt

def value_cal(xs, ys, x_sensor_values, y_sensor_values):
    print(xs.shape())
    print(xs.shape())
    print(x_sensor_values.shape())
    print(y_sensor_values.shape())
    return 1

def earthquake_exercise_setup():
    # explosion detector (using spiral coordinate system)
    # define the coordinate system:

    num_of_points = 2000  # number of points on the spiral
    rate = 25  # angular rate of spiral
    sd = 0.2  # standard deviation of the sensor Gaussian noise

    x = np.zeros(num_of_points)
    y = np.zeros(num_of_points)
    for pt in range(num_of_points):
        theta = rate * 2 * np.pi * pt / num_of_points
        r = pt / num_of_points
        x[pt] = r * np.cos(theta)
        y[pt] = r * np.sin(theta)

    # define the locations of the detection stations on the surface
    # Also define what value on each sensor would be generated by an explosion at internal location s
    num_stations = 30  # number of stations
    x_sensor = np.zeros(num_stations)
    y_sensor = np.zeros(num_stations)
    v = np.zeros((num_of_points, num_stations))
    for sensor in range(num_stations):
        theta_sensor = 2 * np.pi * sensor / num_stations
        x_sensor[sensor] = np.cos(theta_sensor)
        y_sensor[sensor] = np.sin(theta_sensor)
        for pt in range(num_of_points):
            v[pt, sensor] = value_cal(x[pt], y[pt], x_sensor[sensor], y_sensor[sensor])  # explosion value for some value function

def single_explosion_signal_truth(station_x, station_y, truth_x, truth_y):
    distance_sqr = (station_x - truth_x)**2 + (station_y - truth_y)**2
    signal = 1 / (distance_sqr + 0.1)
    return signal

def single_explosion_signal_noisy(station_x, station_y, truth_x, truth_y, sd):
    truth = single_explosion_signal_truth(station_x, station_y, truth_x, truth_y)
    noise = np.random.normal(0, sd)
    return truth + noise

# plotting the basic graph
# Compute areas and colors
np.random.seed(19680801)

num_pts = 5000
rate = 25 # The angular rate of the spiral
theta = np.zeros(num_pts)
r = np.zeros(num_pts)
colors = np.zeros(num_pts)
pt_x = np.zeros(num_pts)
pt_y = np.zeros(num_pts)
for pt in range(num_pts):
    theta[pt] = rate * 2 * np.pi * pt / num_pts
    r[pt] = pt / num_pts
    pt_x[pt] = r[pt] * np.cos(theta[pt])
    pt_y[pt] = r[pt] * np.sin(theta[pt])
    colors[pt] = pt / num_pts;
pt_area = 1

# Plotting stations
num_stations = 10
station_theta = np.zeros(num_stations)
station_r = np.ones(num_stations) * 1.05
station_colors = np.ones(num_stations)
station_x = np.zeros(num_stations)
station_y = np.zeros(num_stations)
station_area = np.ones(num_stations) * 100

for station in range(num_stations):
    station_theta[station] = station * (2 * np.pi / num_stations)
    station_x[station] = station_r[station] * np.cos(station_theta[station])
    station_y[station] = station_r[station] * np.sin(station_theta[station])

# Populating sensor readings
true_sensor_reading = np.zeros(num_stations)
noisy_sensor_reading = np.zeros(num_stations)
ground_truth_x = 0.2
ground_truth_y = 0.2

sd = 0.2
for station in range(num_stations):
    true_sensor_reading[station] = single_explosion_signal_truth(station_x[station], station_y[station], ground_truth_x, ground_truth_y)
    noisy_sensor_reading[station] = single_explosion_signal_noisy(station_x[station], station_y[station], ground_truth_x, ground_truth_y, sd)

# Generating station sensor plots (both true and noisy sensor value)
sensor_size = 1000
true_sensor_reading_thetas = []
noisy_sensor_reading_thetas = []
true_sensor_reading_rs = []
noisy_sensor_reading_rs = []
true_sensor_reading_scaled = true_sensor_reading / np.amax(true_sensor_reading)
noisy_sensor_reading_scaled = noisy_sensor_reading / np.amax(noisy_sensor_reading)

for reading in range(num_stations):
    temp_r_val = station_r[reading]
    # Building the true sensor reading points
    true_theta = station_theta[reading] + 0.1
    num_points = int(np.floor(sensor_size * true_sensor_reading_scaled[reading]))

    for pt in range(num_points):
        r_val = temp_r_val + (1 / sensor_size)
        temp_r_val = r_val
        true_sensor_reading_rs = np.append(true_sensor_reading_rs, r_val)
        true_sensor_reading_thetas = np.append(true_sensor_reading_thetas, true_theta)

    true_sensor_reading_rs = np.array(true_sensor_reading_rs)
    true_sensor_reading_thetas = np.array(true_sensor_reading_thetas)
    # Building the noisy sensor reading points
    noisy_theta = station_theta[reading] - 0.1
    num_points = int(np.floor(sensor_size * noisy_sensor_reading_scaled[reading]))
    temp_r_val = station_r[reading] # reset the r value back to original station r value
    for pt in range(num_points):
        r_val = temp_r_val + (1 / sensor_size)
        temp_r_val = r_val
        noisy_sensor_reading_rs = np.append(noisy_sensor_reading_rs, r_val)
        noisy_sensor_reading_thetas = np.append(noisy_sensor_reading_thetas, noisy_theta)

# ground truth plot
ground_truth_r = np.sqrt(ground_truth_x**2 + ground_truth_y**2)
ground_truth_theta = np.arctan(ground_truth_y/ground_truth_x)

true_sensor_dim = true_sensor_reading_thetas.shape
true_sensor_reading_color = np.ones(true_sensor_dim)

noisy_sensor_dim = noisy_sensor_reading_thetas.shape
noisy_sensor_reading_color = np.ones(noisy_sensor_dim)

sensor_reading_area = 0.2

fig = plt.figure()

# ax for points
ax = fig.add_subplot(111, projection='polar')
ax.grid(False)
ax.set_axis_off()
ax.set_frame_on(True)

ax.scatter(theta, r, c=colors, s=pt_area, cmap='gray_r', alpha=0.5)
ax.scatter(station_theta, station_r, c=station_colors, s=station_area, cmap='hsv', alpha=0.5)
ax.scatter(true_sensor_reading_thetas, true_sensor_reading_rs, c=true_sensor_reading_color, s=sensor_reading_area, cmap="hsv")
ax.scatter(noisy_sensor_reading_thetas, noisy_sensor_reading_rs, c=noisy_sensor_reading_color, s=sensor_reading_area, cmap="viridis")

plt.plot(ground_truth_theta, ground_truth_r , 'r+', mew=2, ms=10)

# annotating the stations by their id
for station in range(num_stations):
    plt.annotate(str(station), xy=(station_theta[station], station_r[station]))

plt.show()
